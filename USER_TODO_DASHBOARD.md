# USER TODO - Configuration Supabase pour Dashboard Analytics

Ce document liste **toutes les t√¢ches que vous devez effectuer dans Supabase** avant que je puisse continuer le d√©veloppement du dashboard. Je ne peux pas effectuer ces modifications de mani√®re s√ªre car elles touchent directement √† la structure de votre base de donn√©es en production.

---

## üìã Vue d'ensemble

**Pourquoi ces t√¢ches manuelles ?**
- Modifications de sch√©ma database (cr√©ation tables, colonnes, indexes)
- Configuration de s√©curit√© critique (RLS policies)
- Optimisations performance (BRIN indexes, materialized views)
- Risque de perte de donn√©es si mal ex√©cut√©es

**Mon r√¥le (Claude Code)** :
- ‚úÖ G√©n√©rer tout le code SQL n√©cessaire (voir ci-dessous)
- ‚úÖ Cr√©er les composants React/Next.js
- ‚úÖ Configurer TanStack Query et routing
- ‚úÖ Impl√©menter les visualisations et filtres

**Votre r√¥le** :
- ‚ö†Ô∏è Ex√©cuter les scripts SQL dans Supabase
- ‚ö†Ô∏è V√©rifier que tout fonctionne
- ‚ö†Ô∏è Me confirmer quand c'est fait

---

## üéØ Checklist des T√¢ches

### Phase 1 : Pr√©paration (5 min)

- [ ] **Backup de la base de donn√©es**
  - Aller dans Supabase Dashboard ‚Üí Database ‚Üí Backups
  - Cr√©er un backup manuel avant toute modification
  - T√©l√©charger un export SQL complet (s√©curit√©)

- [ ] **Ouvrir SQL Editor**
  - Aller dans Supabase Dashboard ‚Üí SQL Editor
  - Cr√©er une nouvelle query nomm√©e "Dashboard Setup"

---

### Phase 2 : Cr√©ation des Tables (10 min)

#### ‚úÖ T√¢che 1 : Cr√©er la table `agents`

**Objectif** : G√©rer les agents vocaux individuels par client

**SQL √† ex√©cuter** :
```sql
-- Table agents
CREATE TABLE IF NOT EXISTS agents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  type TEXT CHECK (type IN ('inbound', 'outbound')),
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'archived')),
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_agents_client_id ON agents(client_id);
CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status) WHERE status = 'active';

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_agents_updated_at
  BEFORE UPDATE ON agents
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS
ALTER TABLE agents ENABLE ROW LEVEL SECURITY;

-- Policy : Users voient les agents de leurs clients
CREATE POLICY "users_view_their_agents"
  ON agents FOR SELECT
  TO authenticated
  USING (
    client_id IN (
      SELECT client_id FROM user_client_permissions
      WHERE user_id = auth.uid()
    )
  );

COMMENT ON TABLE agents IS 'Agents vocaux IA appartenant aux clients';
```

**V√©rification** :
```sql
-- Doit retourner la structure de la table agents
SELECT * FROM agents LIMIT 1;
```

- [ ] **Confirm√© : Table `agents` cr√©√©e avec succ√®s**

---

#### ‚úÖ T√¢che 2 : Cr√©er la table `user_client_permissions`

**Objectif** : G√©rer qui peut voir quels clients (permissions granulaires)

**SQL √† ex√©cuter** :
```sql
-- Table permissions
CREATE TABLE IF NOT EXISTS user_client_permissions (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  permission_level TEXT NOT NULL DEFAULT 'read' CHECK (permission_level IN ('read', 'write', 'admin')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, client_id)
);

-- Index
CREATE INDEX IF NOT EXISTS idx_user_client_permissions_user ON user_client_permissions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_client_permissions_client ON user_client_permissions(client_id);

-- Enable RLS
ALTER TABLE user_client_permissions ENABLE ROW LEVEL SECURITY;

-- Policy : Users voient leurs propres permissions
CREATE POLICY "users_view_own_permissions"
  ON user_client_permissions FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

COMMENT ON TABLE user_client_permissions IS 'Permissions granulaires user-client';
```

**V√©rification** :
```sql
-- Doit retourner la structure de la table
SELECT * FROM user_client_permissions LIMIT 1;
```

- [ ] **Confirm√© : Table `user_client_permissions` cr√©√©e avec succ√®s**

---

### Phase 3 : Modification de la Table `calls` (5 min)

#### ‚úÖ T√¢che 3 : Ajouter la colonne `agent_id`

**Objectif** : Lier chaque appel √† un agent sp√©cifique

**SQL √† ex√©cuter** :
```sql
-- Ajouter colonne agent_id si elle n'existe pas
ALTER TABLE calls
ADD COLUMN IF NOT EXISTS agent_id UUID REFERENCES agents(id) ON DELETE SET NULL;

-- Ajouter index pour performance
CREATE INDEX IF NOT EXISTS idx_calls_agent_id ON calls(agent_id);

COMMENT ON COLUMN calls.agent_id IS 'Agent vocal ayant pass√© cet appel';
```

**V√©rification** :
```sql
-- Doit afficher la colonne agent_id
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'calls' AND column_name = 'agent_id';
```

- [ ] **Confirm√© : Colonne `agent_id` ajout√©e √† `calls`**

---

### Phase 4 : Indexes de Performance (10 min)

#### ‚úÖ T√¢che 4 : Cr√©er les indexes critiques

**Objectif** : Optimiser les requ√™tes time-series et filtres fr√©quents

**SQL √† ex√©cuter** :
```sql
-- BRIN index pour started_at (99% plus l√©ger que B-tree pour time-series)
CREATE INDEX IF NOT EXISTS idx_calls_started_at_brin
ON calls USING BRIN (started_at)
WITH (pages_per_range = 128);

-- Composite indexes pour filtres fr√©quents
CREATE INDEX IF NOT EXISTS idx_calls_client_started
ON calls (client_id, started_at DESC);

CREATE INDEX IF NOT EXISTS idx_calls_agent_started
ON calls (agent_id, started_at DESC);

CREATE INDEX IF NOT EXISTS idx_calls_client_agent_started
ON calls (client_id, agent_id, started_at DESC);

-- Index pour filtrage par call_outcome
CREATE INDEX IF NOT EXISTS idx_calls_outcome
ON calls (call_outcome) WHERE call_outcome IS NOT NULL;

-- Index pour filtrage par √©motion
CREATE INDEX IF NOT EXISTS idx_calls_emotion
ON calls (emotion) WHERE emotion IS NOT NULL;

-- Index pour les RDV
CREATE INDEX IF NOT EXISTS idx_calls_appointments
ON calls (appointment_scheduled_at) WHERE appointment_scheduled_at IS NOT NULL;
```

**V√©rification** :
```sql
-- Doit afficher tous les indexes cr√©√©s
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'calls'
ORDER BY indexname;
```

- [ ] **Confirm√© : Tous les indexes cr√©√©s avec succ√®s**

---

### Phase 5 : Materialized View (15 min)

#### ‚úÖ T√¢che 5 : Cr√©er la vue mat√©rialis√©e pour m√©triques quotidiennes

**Objectif** : Pr√©-calculer les agr√©gations pour am√©liorer les performances

**SQL √† ex√©cuter** :
```sql
-- Vue mat√©rialis√©e pour m√©triques quotidiennes
CREATE MATERIALIZED VIEW IF NOT EXISTS daily_call_metrics AS
SELECT
  client_id,
  agent_id,
  DATE(started_at) as metric_date,

  -- M√©triques prioritaires
  COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL) as appointments_scheduled,
  COUNT(*) FILTER (WHERE call_outcome = 'voicemail') as voicemail_count,
  COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested')) as answered_count,

  -- Dur√©e et co√ªt
  ROUND(AVG(duration_seconds)) as avg_duration_seconds,
  ROUND(SUM(cost)::NUMERIC, 2) as total_cost,
  ROUND(AVG(cost)::NUMERIC, 2) as avg_cost,

  -- Distribution √©motions
  COUNT(*) FILTER (WHERE emotion = 'positive') as emotion_positive,
  COUNT(*) FILTER (WHERE emotion = 'neutral') as emotion_neutral,
  COUNT(*) FILTER (WHERE emotion = 'negative') as emotion_negative,

  -- Total
  COUNT(*) as total_calls

FROM calls
WHERE started_at >= CURRENT_DATE - INTERVAL '365 days'
GROUP BY client_id, agent_id, DATE(started_at);

-- Index sur la vue mat√©rialis√©e
CREATE UNIQUE INDEX IF NOT EXISTS idx_daily_metrics_unique
ON daily_call_metrics (client_id, agent_id, metric_date);

CREATE INDEX IF NOT EXISTS idx_daily_metrics_client_date
ON daily_call_metrics (client_id, metric_date DESC);

CREATE INDEX IF NOT EXISTS idx_daily_metrics_agent_date
ON daily_call_metrics (agent_id, metric_date DESC);

COMMENT ON MATERIALIZED VIEW daily_call_metrics IS 'Agr√©gations quotidiennes des m√©triques d appels (refresh horaire recommand√©)';
```

**Premier refresh** :
```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_call_metrics;
```

**V√©rification** :
```sql
-- Doit afficher des donn√©es agr√©g√©es
SELECT * FROM daily_call_metrics LIMIT 10;

-- V√©rifier le nombre de rows
SELECT COUNT(*) FROM daily_call_metrics;
```

- [ ] **Confirm√© : Materialized view cr√©√©e et popul√©e**

---

#### ‚úÖ T√¢che 5b : Configurer le refresh automatique (OPTIONNEL)

**Option A - Via pg_cron (si disponible)** :
```sql
-- V√©rifier si pg_cron est disponible
SELECT * FROM pg_extension WHERE extname = 'pg_cron';

-- Si disponible, cr√©er un job pour refresh toutes les heures
SELECT cron.schedule(
  'refresh-daily-metrics',
  '0 * * * *', -- Toutes les heures
  $$REFRESH MATERIALIZED VIEW CONCURRENTLY daily_call_metrics$$
);
```

**Option B - Refresh manuel r√©gulier** :
- Cr√©er un reminder pour ex√©cuter le refresh 1x/jour :
```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_call_metrics;
```

**Option C - Via l'application Next.js** :
- Je peux cr√©er un API route qui refresh la view (√† appeler via cron externe)

- [ ] **Confirm√© : Refresh automatique configur√©** (ou d√©cision prise)

---

### Phase 6 : Fonctions SQL pour Queries Complexes (10 min)

#### ‚úÖ T√¢che 6 : Cr√©er la fonction `get_kpi_metrics`

**Objectif** : Fonction optimis√©e pour calculer les KPIs

**SQL √† ex√©cuter** :
```sql
-- Fonction pour obtenir les KPIs avec p√©riode de comparaison
CREATE OR REPLACE FUNCTION get_kpi_metrics(
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ,
  p_client_id UUID DEFAULT NULL,
  p_agent_id UUID DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result JSON;
  prev_start_date TIMESTAMPTZ;
  prev_end_date TIMESTAMPTZ;
BEGIN
  -- Calculer p√©riode pr√©c√©dente de m√™me dur√©e
  prev_end_date := p_start_date - INTERVAL '1 second';
  prev_start_date := prev_end_date - (p_end_date - p_start_date);

  -- Construire le JSON de r√©sultats
  SELECT json_build_object(
    'current_period', (
      SELECT json_build_object(
        'appointments_scheduled', COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL),
        'answer_rate', COALESCE(ROUND((COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested'))::NUMERIC / NULLIF(COUNT(*), 0) * 100), 2), 0),
        'avg_duration', COALESCE(ROUND(AVG(duration_seconds)), 0),
        'avg_cost', COALESCE(ROUND(AVG(cost)::NUMERIC, 2), 0),
        'conversion_rate', COALESCE(ROUND((COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL)::NUMERIC / NULLIF(COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested')), 0) * 100), 2), 0),
        'total_cost', COALESCE(ROUND(SUM(cost)::NUMERIC, 2), 0),
        'total_calls', COUNT(*),
        'cpa', COALESCE(ROUND((SUM(cost) / NULLIF(COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL), 0))::NUMERIC, 2), 0)
      )
      FROM calls
      WHERE started_at >= p_start_date
        AND started_at <= p_end_date
        AND (p_client_id IS NULL OR client_id = p_client_id)
        AND (p_agent_id IS NULL OR agent_id = p_agent_id)
    ),
    'previous_period', (
      SELECT json_build_object(
        'appointments_scheduled', COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL),
        'answer_rate', COALESCE(ROUND((COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested'))::NUMERIC / NULLIF(COUNT(*), 0) * 100), 2), 0),
        'avg_duration', COALESCE(ROUND(AVG(duration_seconds)), 0),
        'avg_cost', COALESCE(ROUND(AVG(cost)::NUMERIC, 2), 0),
        'conversion_rate', COALESCE(ROUND((COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL)::NUMERIC / NULLIF(COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested')), 0) * 100), 2), 0),
        'total_calls', COUNT(*)
      )
      FROM calls
      WHERE started_at >= prev_start_date
        AND started_at <= prev_end_date
        AND (p_client_id IS NULL OR client_id = p_client_id)
        AND (p_agent_id IS NULL OR agent_id = p_agent_id)
    )
  )
  INTO result;

  RETURN result;
END;
$$;

COMMENT ON FUNCTION get_kpi_metrics IS 'Calcule les KPIs pour une p√©riode avec comparaison p√©riode pr√©c√©dente';
```

**V√©rification** :
```sql
-- Test de la fonction (adapter les dates)
SELECT get_kpi_metrics(
  '2024-01-01'::TIMESTAMPTZ,
  NOW()::TIMESTAMPTZ,
  NULL, -- Tous les clients
  NULL  -- Tous les agents
);
```

- [ ] **Confirm√© : Fonction `get_kpi_metrics` cr√©√©e et test√©e**

---

#### ‚úÖ T√¢che 7 : Cr√©er la fonction `get_chart_data`

**Objectif** : Fonction pour obtenir les donn√©es de charts

**SQL √† ex√©cuter** :
```sql
-- Fonction pour obtenir les donn√©es des charts
CREATE OR REPLACE FUNCTION get_chart_data(
  p_start_date TIMESTAMPTZ,
  p_end_date TIMESTAMPTZ,
  p_client_id UUID DEFAULT NULL,
  p_agent_id UUID DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result JSON;
BEGIN
  SELECT json_build_object(
    'call_volume_by_day', (
      SELECT json_agg(
        json_build_object(
          'date', TO_CHAR(DATE(started_at), 'YYYY-MM-DD'),
          'total_calls', COUNT(*),
          'answered_calls', COUNT(*) FILTER (WHERE call_outcome IN ('appointment_scheduled', 'appointment_refused', 'not_interested', 'callback_requested')),
          'appointments', COUNT(*) FILTER (WHERE appointment_scheduled_at IS NOT NULL)
        ) ORDER BY DATE(started_at)
      )
      FROM calls
      WHERE started_at >= p_start_date
        AND started_at <= p_end_date
        AND (p_client_id IS NULL OR client_id = p_client_id)
        AND (p_agent_id IS NULL OR agent_id = p_agent_id)
      GROUP BY DATE(started_at)
    ),
    'emotion_distribution', (
      SELECT json_agg(
        json_build_object(
          'emotion', COALESCE(emotion, 'unknown'),
          'count', COUNT(*)
        )
      )
      FROM calls
      WHERE started_at >= p_start_date
        AND started_at <= p_end_date
        AND (p_client_id IS NULL OR client_id = p_client_id)
        AND (p_agent_id IS NULL OR agent_id = p_agent_id)
      GROUP BY emotion
    ),
    'outcome_distribution', (
      SELECT json_agg(
        json_build_object(
          'outcome', call_outcome::TEXT,
          'count', COUNT(*)
        ) ORDER BY COUNT(*) DESC
      )
      FROM calls
      WHERE started_at >= p_start_date
        AND started_at <= p_end_date
        AND (p_client_id IS NULL OR client_id = p_client_id)
        AND (p_agent_id IS NULL OR agent_id = p_agent_id)
        AND call_outcome IS NOT NULL
      GROUP BY call_outcome
    ),
    'voicemail_by_agent', (
      SELECT json_agg(
        json_build_object(
          'agent', COALESCE(a.name, 'Unknown'),
          'rate', ROUND((COUNT(*) FILTER (WHERE c.call_outcome = 'voicemail')::NUMERIC / NULLIF(COUNT(*), 0) * 100), 2)
        ) ORDER BY ROUND((COUNT(*) FILTER (WHERE c.call_outcome = 'voicemail')::NUMERIC / NULLIF(COUNT(*), 0) * 100), 2) DESC
      )
      FROM calls c
      LEFT JOIN agents a ON c.agent_id = a.id
      WHERE c.started_at >= p_start_date
        AND c.started_at <= p_end_date
        AND (p_client_id IS NULL OR c.client_id = p_client_id)
        AND (p_agent_id IS NULL OR c.agent_id = p_agent_id)
      GROUP BY a.name
    )
  )
  INTO result;

  RETURN result;
END;
$$;

COMMENT ON FUNCTION get_chart_data IS 'Retourne les donn√©es pour tous les charts du dashboard';
```

**V√©rification** :
```sql
-- Test de la fonction
SELECT get_chart_data(
  '2024-01-01'::TIMESTAMPTZ,
  NOW()::TIMESTAMPTZ,
  NULL,
  NULL
);
```

- [ ] **Confirm√© : Fonction `get_chart_data` cr√©√©e et test√©e**

---

### Phase 7 : RLS Policies (15 min)

#### ‚úÖ T√¢che 8 : Configurer les RLS policies sur `calls`

**Objectif** : S√©curiser l'acc√®s aux donn√©es (isolation client)

**SQL √† ex√©cuter** :
```sql
-- S'assurer que RLS est activ√©
ALTER TABLE calls ENABLE ROW LEVEL SECURITY;

-- Supprimer les anciennes policies si elles existent
DROP POLICY IF EXISTS "users_view_their_calls" ON calls;

-- Policy : Users voient les appels de leurs clients assign√©s
CREATE POLICY "users_view_their_calls"
  ON calls FOR SELECT
  TO authenticated
  USING (
    client_id IN (
      SELECT client_id
      FROM user_client_permissions
      WHERE user_id = auth.uid()
    )
  );

-- Policy pour insertion (si n√©cessaire dans le futur)
CREATE POLICY "users_insert_to_their_clients"
  ON calls FOR INSERT
  TO authenticated
  WITH CHECK (
    client_id IN (
      SELECT client_id
      FROM user_client_permissions
      WHERE user_id = auth.uid()
      AND permission_level IN ('write', 'admin')
    )
  );
```

**V√©rification** :
```sql
-- Afficher toutes les policies sur calls
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
FROM pg_policies
WHERE tablename = 'calls';
```

- [ ] **Confirm√© : RLS policies configur√©es sur `calls`**

---

#### ‚úÖ T√¢che 9 : Configurer les RLS policies sur `clients`

**SQL √† ex√©cuter** :
```sql
-- S'assurer que RLS est activ√©
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;

-- Policy : Users voient leurs clients assign√©s
DROP POLICY IF EXISTS "users_view_their_clients" ON clients;
CREATE POLICY "users_view_their_clients"
  ON clients FOR SELECT
  TO authenticated
  USING (
    id IN (
      SELECT client_id
      FROM user_client_permissions
      WHERE user_id = auth.uid()
    )
  );
```

- [ ] **Confirm√© : RLS policies configur√©es sur `clients`**

---

### Phase 8 : Donn√©es de Test (OPTIONNEL - 10 min)

#### ‚úÖ T√¢che 10 : Cr√©er des donn√©es de test

**Objectif** : Avoir des donn√©es pour tester le dashboard

**SQL √† ex√©cuter** :
```sql
-- Cr√©er un agent de test pour chaque client existant
INSERT INTO agents (client_id, name, type, status)
SELECT
  id,
  name || ' - Agent 1',
  'inbound',
  'active'
FROM clients
ON CONFLICT DO NOTHING;

-- Mettre √† jour quelques appels avec des agent_id
WITH agent_mapping AS (
  SELECT
    c.id as client_id,
    a.id as agent_id
  FROM clients c
  LEFT JOIN agents a ON a.client_id = c.id
  WHERE a.type = 'inbound'
  LIMIT 1
)
UPDATE calls
SET agent_id = (SELECT agent_id FROM agent_mapping WHERE agent_mapping.client_id = calls.client_id)
WHERE agent_id IS NULL
  AND client_id IN (SELECT client_id FROM agent_mapping);

-- Refresh la materialized view avec les nouvelles donn√©es
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_call_metrics;
```

**V√©rification** :
```sql
-- V√©rifier qu'on a des agents
SELECT c.name as client_name, a.name as agent_name, a.type, a.status
FROM agents a
JOIN clients c ON a.client_id = c.id;

-- V√©rifier qu'on a des appels avec agents
SELECT COUNT(*), agent_id
FROM calls
GROUP BY agent_id;
```

- [ ] **Confirm√© : Donn√©es de test cr√©√©es** (ou d√©cision de ne pas en cr√©er)

---

### Phase 9 : Configuration Auth (20-30 min)

#### ‚úÖ T√¢che 11 : Cr√©er un utilisateur de test

**Objectif** : Avoir un user pour tester l'authentification

**Via Supabase Dashboard** :
1. Aller dans Authentication ‚Üí Users
2. Cliquer sur "Add user"
3. Cr√©er un utilisateur :
   - Email : `test@voipia.com` (ou votre email)
   - Password : G√©n√©rer un mot de passe fort
   - Auto Confirm : ‚úÖ Oui
4. Copier le `user_id` (UUID)

**Puis dans SQL Editor** :
```sql
-- Assigner des permissions √† cet utilisateur
-- Remplacer 'USER_ID_ICI' par le vrai UUID de l'utilisateur

-- Donner acc√®s √† tous les clients (pour test)
INSERT INTO user_client_permissions (user_id, client_id, permission_level)
SELECT
  'USER_ID_ICI'::UUID,
  id,
  'admin'
FROM clients
ON CONFLICT DO NOTHING;
```

**V√©rification** :
```sql
-- V√©rifier les permissions
SELECT
  u.email,
  c.name as client_name,
  ucp.permission_level
FROM user_client_permissions ucp
JOIN auth.users u ON ucp.user_id = u.id
JOIN clients c ON ucp.client_id = c.id;
```

- [ ] **Confirm√© : Utilisateur de test cr√©√© avec permissions**

---

### Phase 10 : Variables d'Environnement (5 min)

#### ‚úÖ T√¢che 12 : R√©cup√©rer les credentials Supabase

**Via Supabase Dashboard** :
1. Aller dans Settings ‚Üí API
2. Copier :
   - **Project URL** : `https://xxxxx.supabase.co`
   - **anon public key** : `eyJhbGc...` (longue cl√©)

**Cr√©er/Mettre √† jour `.env.local`** dans votre projet :
```env
NEXT_PUBLIC_SUPABASE_URL=https://xxxxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGc...
```

- [ ] **Confirm√© : Fichier `.env.local` cr√©√©/mis √† jour**

---

## ‚úÖ Validation Finale

### Checklist de validation

- [ ] ‚úÖ Toutes les tables cr√©√©es (`agents`, `user_client_permissions`)
- [ ] ‚úÖ Colonne `agent_id` ajout√©e √† `calls`
- [ ] ‚úÖ Tous les indexes cr√©√©s (BRIN + composites)
- [ ] ‚úÖ Materialized view `daily_call_metrics` cr√©√©e et popul√©e
- [ ] ‚úÖ Fonctions SQL cr√©√©es (`get_kpi_metrics`, `get_chart_data`)
- [ ] ‚úÖ RLS policies configur√©es sur toutes les tables
- [ ] ‚úÖ Utilisateur de test cr√©√© avec permissions
- [ ] ‚úÖ Variables d'environnement configur√©es
- [ ] ‚úÖ Backup de la base effectu√©

### Tests √† effectuer

**Test 1 - Tables et donn√©es** :
```sql
-- Doit retourner des r√©sultats
SELECT COUNT(*) FROM agents;
SELECT COUNT(*) FROM calls WHERE agent_id IS NOT NULL;
SELECT COUNT(*) FROM daily_call_metrics;
```

**Test 2 - Fonctions** :
```sql
-- Doit retourner du JSON avec des KPIs
SELECT get_kpi_metrics(
  (NOW() - INTERVAL '30 days')::TIMESTAMPTZ,
  NOW()::TIMESTAMPTZ,
  NULL,
  NULL
);

-- Doit retourner du JSON avec des donn√©es de charts
SELECT get_chart_data(
  (NOW() - INTERVAL '30 days')::TIMESTAMPTZ,
  NOW()::TIMESTAMPTZ,
  NULL,
  NULL
);
```

**Test 3 - RLS** :
```sql
-- En tant qu'utilisateur connect√©, doit voir seulement les clients autoris√©s
-- (N√©cessite d'√™tre connect√© via l'app pour vraiment tester)
SELECT * FROM calls LIMIT 10;
```

---

## üöÄ Prochaines √âtapes

### Une fois TOUTES les t√¢ches coch√©es :

1. **Me confirmer** :
   - "J'ai termin√© toutes les t√¢ches SQL"
   - Partager un screenshot ou copier/coller des r√©sultats de validation

2. **Je vais d√©velopper** :
   - Installation des d√©pendances npm
   - Cr√©ation de la structure de composants
   - Configuration TanStack Query
   - Impl√©mentation du layout dashboard
   - Cr√©ation des filtres
   - Cr√©ation des KPI cards
   - Cr√©ation des charts
   - Mise en place de l'authentification c√¥t√© Next.js

3. **Tests ensemble** :
   - V√©rifier que l'authentification fonctionne
   - V√©rifier que les donn√©es s'affichent correctement
   - V√©rifier que les filtres fonctionnent
   - V√©rifier que le RLS est respect√©

---

## üìû Support

### Si vous rencontrez un probl√®me

**Probl√®me : Une query SQL √©choue**
- Lire le message d'erreur complet
- Me le partager avec le contexte (quelle t√¢che)
- Je vous fournirai une version corrig√©e

**Probl√®me : RLS trop restrictif (aucune donn√©e visible)**
- Temporairement d√©sactiver RLS pour tester :
```sql
ALTER TABLE calls DISABLE ROW LEVEL SECURITY;
```
- Puis r√©activer et ajuster les policies

**Probl√®me : Performance lente**
- V√©rifier que tous les indexes sont cr√©√©s
- Ex√©cuter `ANALYZE calls;` pour mettre √† jour les statistiques
- Refresh la materialized view

---

## üìù Notes Importantes

### Attention aux donn√©es sensibles
- ‚ö†Ô∏è Ne JAMAIS partager votre `SUPABASE_SERVICE_ROLE_KEY` (seulement anon key)
- ‚ö†Ô∏è Tester les RLS policies avant de d√©ployer en production
- ‚ö†Ô∏è Faire un backup avant toute modification majeure

### Migration future
- Tous les scripts SQL ci-dessus peuvent √™tre sauvegard√©s en tant que migration
- Cr√©er un fichier `supabase/migrations/20250115_dashboard_setup.sql`
- Permet de reproduire l'installation sur un autre environnement

### Monitoring
- Surveiller les performances des queries dans Supabase Dashboard ‚Üí Database ‚Üí Query Performance
- Les BRIN indexes sont optimaux pour vos donn√©es time-series
- La materialized view doit √™tre refresh r√©guli√®rement

---

**Version** : 1.0
**Date** : 2025-01-15
**Auteur** : Claude Code

**Temps estim√© total : 1h30 - 2h00**

---

## üéâ F√©licitations !

Une fois toutes ces t√¢ches compl√©t√©es, vous aurez :
- ‚úÖ Une base de donn√©es optimis√©e pour analytics
- ‚úÖ Des queries ultra-rapides gr√¢ce aux indexes
- ‚úÖ Une s√©curit√© robuste avec RLS
- ‚úÖ Des fonctions SQL r√©utilisables
- ‚úÖ Une architecture pr√™te pour le dashboard

**Je suis pr√™t √† d√©velopper d√®s que vous aurez termin√© !** üöÄ
